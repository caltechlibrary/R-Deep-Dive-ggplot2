---
title: "R Notebook"
output: html_notebook
---

# 1 - Introduction - About R Notebooks

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. In R Markdown documents, code is embedded in chunks, marked off by three back ticks and then the designation {r}. You can add additional detail about the chunk after the 'r', i.e. setup, information about the calculation, etc. You can also specify if you want the code itself to be included in any output document (the 'echo' option), and if you want any displayed results to be included (the 'eval' option). By default both options are set to true, so both code and output will be included in any output. We will use code chunks throughout this document for examples, and you will also create your own code chunks.

## How to run a code chunk

To execute a code chunk, click the *Run* button within the chunk (green arrow in the top right), or put your cursor inside the code chunk grey window and press *Cmd+Shift+Enter*.

## Document organization using Markdown

You'll also notice that sections are marked off by hashmarks - #. This provides formatting when publishing this document as a PDF, slideshow, etc. It also allows for navigation via the navigation bar at the bottom of this document window. You can navigate throughout the document using the menu.

## Saving and previewing the notebook

When you save the notebook, an HTML file containing the code and output will be saved alongside it. Click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file - this will appear in the right hand side window in the *Viewer* tab. The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


# 2 - Setup

This set of commands downlaods, installs and attaches packages we will need for this lesson. If you get a message asking to restart R, click Yes. If you get asked to recompile anything from a source binary, type Yes in the console. Run the code in this code chunk by following the directions given in the *Introduction - How to run a code chunk* section.

```{r setup, eval=F, echo=T}
# You can include comments in code chunks by using a hash at the beginning of the line.
# For this chunk, I set eval=F so you don't get all the package loading messages cluttering up your HTML output.

install.packages("tidyverse")
install.packages("caTools")
install.packages("bitops")
install.packages("ggplot2")
install.packages("PeriodicTable")
library("tidyverse")
library("caTools")
library("bitops")
library("ggplot2")
library("PeriodicTable")
```

We will be working with a dataset from the **PeriodicTable: Periodic Table of the Elements package by Julien Id√©**. Information and documentation about this dataset can be found here: [https://cran.r-project.org/package=PeriodicTable](https://cran.r-project.org/package=PeriodicTable).

Run the code chunk below to load this dataset into the R environment.

```{r load_dataset}
data("periodicTable")
```

You should now see "periodicTable" in the Environment tab on the right side of your RStudio window.


# 3 - Simple Scatter Plot

There's lots of data that we can play with here. Let's start by making a simple plot of atomic mass versus atomic number to check the integrity of our data. What should this plot look like? Run the code below to generate a graph.

```{r plot_for_data_integrity}
ggplot(data=periodicTable, aes(x=numb,y=mass)) + geom_point()
```

This is an example of the most basic of ggplots. It has three key elements:
1. "data=": the data you are plotting (usually the name of your data frame in your environment)
2. "aes()": these are the aesthetic mappings for the plot - how are we visually representing the data variables. The basic ones used here are:
- what data to plot on the x axis
- what data to plot on the y axis
3. An additional layer (signified by the + symbol) to describe what the plotted data should look like using the geom designation. 

In this case, we are using the periodicTable data frame, and plotting numb on x and mass on y. We are specifiying the data be represented as individual points.


## Exercise 1 - Finding A Pattern

Make a scatter plot of density (y axis) versus atomic mass (x axis). Plot the data as points.
Add a new chunk by clicking the *Insert Chunk* button (top of the window on the toolbar) or by pressing *Cmd+Option+I*.

```{r finding_a_pattern}
ggplot(data=periodicTable,aes(x=mass,y=density)) + geom_point()
```


# Exercise 2 - Adding Color

We can see from Exercise 1 the periodicity behind the periodic table :) We can use color to further pick out the changes from the table by coloring the points according to what period they are in. We can do this by specifying an additional aesthetic using "aes()".

Add a new chunk by clicking the *Insert Chunk* button (top of the window on the toolbar) or by pressing *Cmd+Option+I*.
Recreate your graph from above, but add the following to the main plot aesthetics, after the x and y specification:
color=period

```{r adding_color}
ggplot(data=periodicTable,aes(x=mass,y=density,color=period)) + geom_point()
```

This shows us the variation, but it would be more accurate to have the periods as discrete colors and not a gradient. The reason it plotted period as a gradient is because in the data frame, period is an integer. ggplot treats number and integer vectors as continuous variables by default - hence it uses a gradient color scheme. In this case, we want period to be a categorical value, or a factor. This can be done by changing color=period to color=factor(period).

Make this modification and replot. (Watch your parenthesis!)

Add a new chunk by clicking the *Insert Chunk* button (top of the window on the toolbar) or by pressing *Cmd+Option+I*.

```{r}
ggplot(data=periodicTable,aes(x=mass,y=density,color=factor(period))) + geom_point()
```

Alternately, to get the same effect, you can change the data type for that column directly in the data frame. You can do that with the following command:

```{r eval=F, echo=T}
periodicTable$period <- factor(periodicTable$period)
```

However, if you're not sure you want to permanently change a data type, just modify it in the ggplot expression.
## Can you change it back to an integer? 


# Exercise 3 - Adding a Fit

Let's go back to our original graph of mass versus numb:

```{r plot_for_data_integrity_2}
ggplot(data=periodicTable,aes(x=numb,y=mass)) + geom_point()
```

We want to add a linear fit to this graph. We can do this by adding a layer of geom_smooth() and specifying the model we want to model with.
# add info on method

```{r layered_geoms_lm}
ggplot(data=periodicTable,aes(x=numb,y=mass)) + geom_point() + geom_smooth(method="lm")
```

It might be useful to display the parameters, like slope and intercept, of the fitted line on the graph. How can we do that?
Although the plot is calculated by ggplot, we need to do the calculation for the fit outside of ggplot in order to get the exact numbers. Then we can add them to the plot.

The following code runs a simple linear model approximation on our data ("lm"), stores it in an object called 'mass_correlation', and displays the slope and intercept values of the line we generated above. Run the code below. Do the numbers make sense?

```{r generate_correlation_values}
mass_correlation <- lm(mass ~ numb, data=periodicTable)
coef(summary(mass_correlation))
```

We can pull out the specific correlation values using the following indices:

```{r display_correlation_values}
mass_correlation$coefficients[1]
mass_correlation$coefficients[2]
```

Since we are focusing on plotting and not on statistics, let's figure out how to get this on our plot. Believe it or not this is not as straightforward as one might think.


```{r}
ggplot(data=periodicTable,aes(x=numb,y=mass)) + geom_point() + geom_smooth(method="lm") + annotate("text", x=5, y=5, label=mass_correlation$coefficients[1])
```


# Exercise 4 - Other Types of Visualizations

We have a number of different variables we can look at. Let's make a bar chart to count how many elements there are of each type. 

```{r element_type_histogram}
ggplot(data=periodicTable) + geom_bar(mapping=aes(x=type))
```

You can pop out the graph into a separate window to de-smush the x-axis by clicking the small square icon (next to the arrows) in the top right of the graph window.


# Exercise 5 - Customizing Axes

Let's add some axes titles and a chart title to our type plot from Exercise 4. We can add a layer of labels using the following:
+ labs(x = "X Axis Label", y = "Y Axis Label", title = "Plot Title")

Add a new chunk by clicking the *Insert Chunk* button (top of the window on the toolbar) or by pressing *Cmd+Option+I*.
Recreate the graph from Exercise 4 and label the X-axis "Element Type", Y-axis "Number of Elements", and the plot title "Numbers of Elements by Type". 

```{r label_customization}
ggplot(data=periodicTable) + geom_bar(mapping=aes(x=type)) + labs(x="Element Type", y="Number of Elements", title="Numbers of Elements by Type")
```

What would make this plot look a little better?

We can rotate the X-axis label text using a theme() layer. The theme() layer is where all the non-content (i.e. non-data) elements of our graphs live. There are tons of options for themes (use help -> theme), and also many pre-defined themes. 

To make our text a little easier to read, add the following layer to the graph:
+ theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5))
The 'element_text' command will change the 'angle', 'hjust' (horizontal justification/position) and 'vjust' (vertical justification/position) for the text of the X axis element (axis.text.x).

Add a new chunk by clicking the *Insert Chunk* button (top of the window on the toolbar) or by pressing *Cmd+Option+I*.

```{r rotated_x_axis_labels}
ggplot(data=periodicTable) + geom_bar(mapping=aes(x=type)) + labs(x="Element Type", y="Number of Elements", title="Numbers of Elements by Type") + theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5))
```

# Exercise 6 - Assigning a Plot to an Object for Reuse

Let's say you want to experiment with a few different label types, but do not want to have to re-type the entire ggplot command every time you make your graph. At any point, with any number of layers, a ggplot can be assigned to an object, and that object can then be called and modified with further layers.

Run the following code chunk to assign our element type plot, without label modifications, to an object called et. The code will then display the et object. 

```{r}
et <- ggplot(data=periodicTable) + geom_bar(mapping=aes(x=type)) + labs(x="Element Type", y="Number of Elements", title="Numbers of Elements by Type")
et
```

Now, if we want to add a theme layer to our base et plot, we can simply run:
et + theme()

Recreate our element type plot using the et object, but rotate the X axis text 45 degrees. Add a new chunk by clicking the *Insert Chunk* button (top of the window on the toolbar) or by pressing *Cmd+Option+I*.

```{r}
et + theme(axis.text.x=element_text(angle=45,hjust=1,vjust=0.5))
```

Challenge: see if you can get the text to line up just below the X axis! What element of element_text do you need to change?

You can see now that a new object, et, is available in the Global Environment, and you can inspect the additional plotting parameters that are stored in there. Why is this important? You may have a situation where you will be working with the same basic plot type over and over again - this gives you a programmatic way to modify aspects of the graph without retyping (or copy/pasting) the entire command. In general, for reproducible analysis, using objects is highly recommended. 

# Exercise 7 - How Many Phases?

Based on what we've done so far, create a bar plot that shows how many elements there are of each phase. Label with an appropriate title and appropriate axes names.

Add a new chunk by clicking the *Insert Chunk* button (top of the window on the toolbar) or by pressing *Cmd+Option+I*.

```{r how_many_phases}
ggplot(data=periodicTable) + geom_bar(mapping=aes(x=phase)) + xlab("Element Phase") + ylab("Number of Elements")
```

## NA omit for this graph

# Exercise 8 - Density Plot

```{r}
ggplot(data=periodicTable,aes(x=mass,y=rion)) + geom_density2d()
```

```{r}
ggplot(data=periodicTable,aes(x=mass,y=rion)) + geom_bin2d()
```

Can we get them to a point where they have a graph that is reproducible & reusable?

# Three-Dimensional Plots: Periodic Table Trends

We know that there are trends that we can see in the periodic table. This is an example of three-dimensional data. We have the two dimensions of the table - row and column - and our third dimension is the property that varies with them. Examples of this variance can be seen in ionic radius, electronegativity, etc.

Let's make a plot of the periodic table that will show some of these trends. Run the code below to create a plot of the periodic table showing variance of electronegativiy with table position. The main layer creates the table, with X being the column and Y being the row. One type of 3D plot is geom_tile, and the aesthetic that we tell it to fill with is the Eneg (electronegativity) value (the "z" direction). So we should expect to see a color variance (what type of vector is Eneg?) with position in X and Y.

```{r}
ggplot(data=periodicTable,aes(x=col,y=row)) + geom_tile(aes(fill=Eneg))
```

So this looks close - what do we need to do to fix this?

Answers: flip the row axis, add axis marks for rows and columns.

```{r}
ggplot(data=periodicTable,aes(x=col,y=row)) + geom_tile(aes(fill=Eneg)) + scale_y_reverse(breaks=seq(1,10,1)) + scale_x_continuous(breaks=c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18))
```

# When were most of the elements discovered?

Histogram of years

```{r}
ggplot(data=periodicTable,aes(x=year)) + geom_histogram(binwidth = 1) + scale_x_continuous(breaks=seq(1200,2050,50))
```


# References

Consider adding citation management?
cite the packages - writebib
More information can always be found in the help!
ggplot2 reference: https://ggplot2.tidyverse.org/reference/
ggplot2: Elegant Graphics for Data Analysis
R for Data Science, Chapter 3: Data Visualization - http://r4ds.had.co.nz/data-visualisation.html
ggplot2 Google Group: https://groups.google.com/forum/#!forum/ggplot2
ggplot2 cheatsheet (2016): https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf

